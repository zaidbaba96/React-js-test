{"version":3,"sources":["../../src/ts/filter/floating/provided/simpleFloatingFilter.ts"],"names":[],"mappings":"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","file":"simpleFloatingFilter.js","sourcesContent":["import { Component } from '../../../widgets/component';\nimport { IFloatingFilterComp, IFloatingFilterParams } from '../floatingFilter';\nimport { ProvidedFilterModel } from '../../../interfaces/iFilter';\nimport { ICombinedSimpleModel, ISimpleFilterModel, SimpleFilter } from '../../provided/simpleFilter';\nimport { OptionsFactory } from '../../provided/optionsFactory';\nimport { IScalarFilterParams } from '../../provided/scalarFilter';\nimport { FilterChangedEvent } from '../../../events';\n\nexport abstract class SimpleFloatingFilter extends Component implements IFloatingFilterComp {\n\n    // this method is on IFloatingFilterComp. because it's not implemented at this level, we have to\n    // define it as an abstract method. it gets implemented in sub classes.\n    public abstract onParentModelChanged(model: ProvidedFilterModel, event: FilterChangedEvent): void;\n\n    // creates text equivalent of FilterModel. if it's a combined model, this takes just one condition.\n    protected abstract conditionToString(condition: ProvidedFilterModel): string;\n    protected abstract getDefaultFilterOptions(): string[];\n    protected abstract setEditable(editable: boolean): void;\n\n    private lastType: string | null | undefined;\n\n    private optionsFactory: OptionsFactory;\n\n    protected getDefaultDebounceMs(): number {\n        return 0;\n    }\n\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    public destroy(): void {\n        super.destroy();\n    }\n\n    // used by:\n    // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.\n    // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)\n    protected getTextFromModel(model: ProvidedFilterModel): string | null {\n        if (!model) { return null; }\n\n        const isCombined = (model as any).operator;\n\n        if (isCombined) {\n            const combinedModel = model as ICombinedSimpleModel<ISimpleFilterModel>;\n\n            const con1Str = this.conditionToString(combinedModel.condition1);\n            const con2Str = this.conditionToString(combinedModel.condition2);\n\n            return `${con1Str} ${combinedModel.operator} ${con2Str}`;\n        } else {\n            const condition = model as ISimpleFilterModel;\n            const customOption = this.optionsFactory.getCustomOption(condition.type);\n\n            // For custom filter options we display the Name of the filter instead\n            // of displaying the `from` value, as it wouldn't be relevant\n            if (customOption && customOption.hideFilterInput) {\n                this.gridOptionsWrapper.getLocaleTextFunc()(customOption.displayKey, customOption.displayName);\n                return customOption.displayName;\n            }\n            return this.conditionToString(condition);\n        }\n    }\n\n    protected isEventFromFloatingFilter(event: FilterChangedEvent): boolean | undefined {\n        return event && event.afterFloatingFilter;\n    }\n\n    protected getLastType(): string | null | undefined {\n        return this.lastType;\n    }\n\n    protected setLastTypeFromModel(model: ProvidedFilterModel): void {\n        // if no model provided by the parent filter use default\n        if (!model) {\n            this.lastType = this.optionsFactory.getDefaultOption();\n            return;\n        }\n\n        const isCombined = (model as any).operator;\n\n        let condition: ISimpleFilterModel;\n\n        if (isCombined) {\n            const combinedModel = model as ICombinedSimpleModel<ISimpleFilterModel>;\n            condition = combinedModel.condition1;\n        } else {\n            condition = model as ISimpleFilterModel;\n        }\n\n        this.lastType = condition.type;\n    }\n\n    protected canWeEditAfterModelFromParentFilter(model: ProvidedFilterModel): boolean {\n        if (!model) {\n            // if no model, then we can edit as long as the lastType is something we can edit, as this\n            // is the type we will provide to the parent filter if the user decides to use the floating filter.\n            return this.isTypeEditable(this.lastType);\n        }\n\n        // never allow editing if the filter is combined (ie has two parts)\n        const isCombined = (model as any).operator;\n\n        if (isCombined) {\n            return false;\n        }\n\n        const simpleModel = model as ISimpleFilterModel;\n\n        return this.isTypeEditable(simpleModel.type);\n    }\n\n    public init(params: IFloatingFilterParams): void {\n        this.optionsFactory = new OptionsFactory();\n        this.optionsFactory.init(params.filterParams as IScalarFilterParams, this.getDefaultFilterOptions());\n        this.lastType = this.optionsFactory.getDefaultOption();\n\n        // we are editable if:\n        // 1) there is a type (user has configured filter wrong if not type)\n        //  AND\n        // 2) the default type is not 'in range'\n        const editable = this.isTypeEditable(this.lastType);\n        this.setEditable(editable);\n    }\n\n    private doesFilterHaveHiddenInput(filterType: string) {\n        const customFilterOption = this.optionsFactory.getCustomOption(filterType);\n        return customFilterOption && customFilterOption.hideFilterInput;\n    }\n\n    private isTypeEditable(type?: string | null): boolean {\n        return !!type && !this.doesFilterHaveHiddenInput(type) &&\n            type !== SimpleFilter.IN_RANGE\n            && type !== SimpleFilter.EMPTY;\n    }\n}\n"]}